// vingo/vingo.go
package vingo

import (
	"fmt"
	"html"
	"os"
	"path/filepath"
	"reflect"
	"regexp"
	"strconv"
	"strings"
	"sync"
	"time"
)

// -------------------- Public API --------------------

type Template struct {
	Filepath string
	Nodes    []Node
	ModTime  time.Time
}

var (
	// cache: filepath -> compiled template
	tplCache   = map[string]*Template{}
	cacheMutex sync.RWMutex
)

// Render: template dosyasını oku, compile et (gerekirse cache'den), ve işle
func Render(file string, data map[string]interface{}) (string, error) {
	abs, err := filepath.Abs(file)
	if err != nil {
		abs = file
	}

	tpl, err := getOrCompile(abs)
	if err != nil {
		return "", err
	}

	// Evaluate
	out := &strings.Builder{}
	for _, n := range tpl.Nodes {
		out.WriteString(n.Eval(data))
	}
	return out.String(), nil
}

// getOrCompile: cache kontrolü + compile
func getOrCompile(path string) (*Template, error) {
	stat, err := os.Stat(path)
	if err != nil {
		return nil, err
	}
	mod := stat.ModTime()

	cacheMutex.RLock()
	tpl, exists := tplCache[path]
	cacheMutex.RUnlock()

	if exists && tpl.ModTime.Equal(mod) {
		return tpl, nil
	}

	// compile
	b, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	content := string(b)

	tokens := tokenize(content)
	nodes, err := compileTokens(tokens)
	if err != nil {
		return nil, err
	}

	newTpl := &Template{
		Filepath: path,
		Nodes:    nodes,
		ModTime:  mod,
	}

	cacheMutex.Lock()
	tplCache[path] = newTpl
	cacheMutex.Unlock()

	return newTpl, nil
}

// -------------------- Tokenizer (mevcut mantığın geliştirilmiş hali) --------------------

type TokenType int

const (
	TText TokenType = iota
	TVar
	TIf
	TElseIf
	TElse
	TEndIf
	TFor
	TEndFor
	TSwitch
	TCase
	TDefault
	TEndSwitch
)

type Token struct {
	Type    TokenType
	Value   string // for Var: expression or name; for If/For/Switch/Case: expression / raw
	Default string // for Var default literal (if provided)
	Raw     string // raw tag text
}

var (
	varPattern       = regexp.MustCompile(`^\s*(\w+(?:\.\w+)*)(?:\s*\|\s*"(.*?)")?\s*$`)
	ifPattern        = regexp.MustCompile(`^if\s+(.+)$`)
	elseifPattern    = regexp.MustCompile(`^elseif\s+(.+)$`)
	elsePattern      = regexp.MustCompile(`^else$`)
	endifPattern     = regexp.MustCompile(`^/if$`)
	forPattern       = regexp.MustCompile(`^for\s+(.+)\s+in\s+(.+)$`)
	endforPattern    = regexp.MustCompile(`^/for$`)
	switchPattern    = regexp.MustCompile(`^switch\s+(.+)$`)
	casePattern      = regexp.MustCompile(`^case\s+(.+)$`)
	defaultPattern   = regexp.MustCompile(`^default$`)
	endswitchPattern = regexp.MustCompile(`^/switch$`)
)

func tokenize(input string) []*Token {
	var tokens []*Token
	parts := strings.Split(input, "<{")

	for _, part := range parts {
		if part == "" {
			continue
		}

		sub := strings.SplitN(part, "}>", 2)
		if len(sub) == 2 {
			tag := strings.TrimSpace(sub[0])
			rest := sub[1]

			switch {
			case ifPattern.MatchString(tag):
				m := ifPattern.FindStringSubmatch(tag)
				tokens = append(tokens, &Token{Type: TIf, Value: m[1], Raw: tag})
			case elseifPattern.MatchString(tag):
				m := elseifPattern.FindStringSubmatch(tag)
				tokens = append(tokens, &Token{Type: TElseIf, Value: m[1], Raw: tag})
			case elsePattern.MatchString(tag):
				tokens = append(tokens, &Token{Type: TElse, Raw: tag})
			case endifPattern.MatchString(tag):
				tokens = append(tokens, &Token{Type: TEndIf, Raw: tag})
			case forPattern.MatchString(tag):
				m := forPattern.FindStringSubmatch(tag)
				// m[1] could be "idx, item" or "item"
				tokens = append(tokens, &Token{Type: TFor, Value: strings.TrimSpace(m[1]) + ":" + strings.TrimSpace(m[2]), Raw: tag})
			case endforPattern.MatchString(tag):
				tokens = append(tokens, &Token{Type: TEndFor, Raw: tag})
			case switchPattern.MatchString(tag):
				m := switchPattern.FindStringSubmatch(tag)
				tokens = append(tokens, &Token{Type: TSwitch, Value: m[1], Raw: tag})
			case casePattern.MatchString(tag):
				m := casePattern.FindStringSubmatch(tag)
				tokens = append(tokens, &Token{Type: TCase, Value: m[1], Raw: tag})
			case defaultPattern.MatchString(tag):
				tokens = append(tokens, &Token{Type: TDefault, Raw: tag})
			case endswitchPattern.MatchString(tag):
				tokens = append(tokens, &Token{Type: TEndSwitch, Raw: tag})
			case varPattern.MatchString(tag):
				m := varPattern.FindStringSubmatch(tag)
				tokens = append(tokens, &Token{Type: TVar, Value: m[1], Default: m[2], Raw: tag})
			default:
				// treat as text containing the tag (unknown tag kept)
				tokens = append(tokens, &Token{Type: TText, Value: "<{" + tag + "}>", Raw: tag})
			}

			if rest != "" {
				tokens = append(tokens, &Token{Type: TText, Value: rest})
			}
		} else {
			// trailing text without closing tag
			tokens = append(tokens, &Token{Type: TText, Value: "<{" + part})
		}
	}

	return tokens
}

// -------------------- AST Nodes --------------------

type Node interface {
	Eval(data map[string]interface{}) string
}

type TextNode struct {
	Text string
}

func (n *TextNode) Eval(data map[string]interface{}) string {
	return n.Text
}

type VarNode struct {
	Name    string
	Default string
	Filters []string
}

func (n *VarNode) Eval(data map[string]interface{}) string {
	val, ok := lookup(data, n.Name)
	var out string
	if ok {
		out = fmt.Sprintf("%v", val)
	} else if n.Default != "" {
		out = n.Default
	} else {
		out = ""
	}
	// Apply filters in order
	for _, f := range n.Filters {
		out = applyFilter(f, out)
	}
	return out
}

type IfNode struct {
	Branches []IfBranch
	Else     []Node
}

type IfBranch struct {
	Expr string
	Body []Node
}

func (n *IfNode) Eval(data map[string]interface{}) string {
	for _, b := range n.Branches {
		ok, err := evalCondition(b.Expr, data)
		if err == nil && ok {
			return evalNodes(b.Body, data)
		}
	}
	// else
	return evalNodes(n.Else, data)
}

type ForNode struct {
	IndexVar string // optional, can be ""
	ItemVar  string
	ListExpr string
	Body     []Node
}

func (n *ForNode) Eval(data map[string]interface{}) string {
	seq, ok := lookup(data, n.ListExpr)
	if !ok {
		return ""
	}
	v := reflect.ValueOf(seq)
	kind := v.Kind()
	if kind != reflect.Slice && kind != reflect.Array {
		return ""
	}
	length := v.Len()
	out := &strings.Builder{}
	for i := 0; i < length; i++ {
		item := v.Index(i).Interface()
		newData := shallowCopyMap(data)
		if n.IndexVar != "" {
			newData[n.IndexVar] = i
		}
		newData[n.ItemVar] = item
		// loop meta
		loopMeta := map[string]interface{}{
			"Index":  i,
			"First":  i == 0,
			"Last":   i == length-1,
			"Length": length,
		}
		newData["loop"] = loopMeta
		out.WriteString(evalNodes(n.Body, newData))
	}
	return out.String()
}

type SwitchNode struct {
	Expr    string
	Cases   []SwitchCase
	Default []Node
}

type SwitchCase struct {
	Cond string
	Body []Node
}

func (n *SwitchNode) Eval(data map[string]interface{}) string {
	val := lookupVal(data, n.Expr)
	// Try to match with case expressions: we evaluate each case as condition:
	for _, c := range n.Cases {
		// if case expression is a simple literal equal to val -> match
		// Alternatively evaluate case as condition using evalCondition, but allow bare literal too.
		ok, err := evalConditionWithValue(c.Cond, val, data)
		if err == nil && ok {
			return evalNodes(c.Body, data)
		}
	}
	// default
	return evalNodes(n.Default, data)
}

// -------------------- compile (tokens -> AST nodes) --------------------

func compileTokens(tokens []*Token) ([]Node, error) {
	nodes := []Node{}
	i := 0
	for i < len(tokens) {
		t := tokens[i]
		switch t.Type {
		case TText:
			nodes = append(nodes, &TextNode{Text: t.Value})
			i++
		case TVar:
			// parse filters from t.Raw maybe in future; currently only default supported.
			filters := []string{}
			// if user wants filters like <{ var | upper }>, varPattern must be extended.
			nodes = append(nodes, &VarNode{Name: t.Value, Default: t.Default, Filters: filters})
			i++
		case TIf:
			ifNode, ni, err := parseIf(tokens, i)
			if err != nil {
				return nil, err
			}
			nodes = append(nodes, ifNode)
			i = ni
		case TFor:
			forNode, ni, err := parseFor(tokens, i)
			if err != nil {
				return nil, err
			}
			nodes = append(nodes, forNode)
			i = ni
		case TSwitch:
			switchNode, ni, err := parseSwitch(tokens, i)
			if err != nil {
				return nil, err
			}
			nodes = append(nodes, switchNode)
			i = ni
		default:
			return nil, fmt.Errorf("unexpected token %v at position %d (raw: %s)", t.Type, i, t.Raw)
		}
	}
	return nodes, nil
}

func parseIf(tokens []*Token, start int) (*IfNode, int, error) {
	// tokens[start] is TIf
	root := &IfNode{}
	branches := []IfBranch{{Expr: tokens[start].Value, Body: []Node{}}}
	elseBody := []Node{}
	currentBody := &branches[0].Body
	depth := 0

	i := start + 1
	for i < len(tokens) {
		t := tokens[i]
		switch t.Type {
		case TIf:
			// nested if: append token as part of body by compiling nested structure
			nested, ni, err := parseIf(tokens, i)
			if err != nil {
				return nil, 0, err
			}
			*currentBody = append(*currentBody, nested)
			i = ni
			continue
		case TEndIf:
			if depth == 0 {
				// finish
				root.Branches = branches
				root.Else = elseBody
				return root, i + 1, nil
			}
			depth--
			*currentBody = append(*currentBody, &TextNode{Text: t.Value})
		case TElseIf:
			if depth == 0 {
				branches = append(branches, IfBranch{Expr: t.Value, Body: []Node{}})
				currentBody = &branches[len(branches)-1].Body
				i++
				continue
			}
			*currentBody = append(*currentBody, &TextNode{Text: t.Value})
		case TElse:
			if depth == 0 {
				elseBody = []Node{}
				currentBody = &elseBody
				i++
				continue
			}
			*currentBody = append(*currentBody, &TextNode{Text: t.Value})
		case TFor:
			fnode, ni, err := parseFor(tokens, i)
			if err != nil {
				return nil, 0, err
			}
			*currentBody = append(*currentBody, fnode)
			i = ni
			continue
		case TSwitch:
			snode, ni, err := parseSwitch(tokens, i)
			if err != nil {
				return nil, 0, err
			}
			*currentBody = append(*currentBody, snode)
			i = ni
			continue
		default:
			// Text or Var
			switch t.Type {
			case TText:
				*currentBody = append(*currentBody, &TextNode{Text: t.Value})
			case TVar:
				*currentBody = append(*currentBody, &VarNode{Name: t.Value, Default: t.Default})
			default:
				return nil, 0, fmt.Errorf("unexpected token inside if: %v", t.Type)
			}
			i++
		}
	}
	return nil, 0, fmt.Errorf("unclosed if starting at token %d", start)
}

func parseFor(tokens []*Token, start int) (*ForNode, int, error) {
	// tokens[start] is TFor with Value like "idx, item:listExpr" or "item:listExpr"
	parts := strings.SplitN(tokens[start].Value, ":", 2)
	if len(parts) != 2 {
		return nil, 0, fmt.Errorf("invalid for tag: %s", tokens[start].Raw)
	}
	left := strings.TrimSpace(parts[0])
	listExpr := strings.TrimSpace(parts[1])

	indexVar := ""
	itemVar := ""
	if strings.Contains(left, ",") {
		p := strings.SplitN(left, ",", 2)
		indexVar = strings.TrimSpace(p[0])
		itemVar = strings.TrimSpace(p[1])
	} else {
		itemVar = left
	}

	node := &ForNode{IndexVar: indexVar, ItemVar: itemVar, ListExpr: listExpr, Body: []Node{}}
	i := start + 1
	depth := 0
	for i < len(tokens) {
		t := tokens[i]
		switch t.Type {
		case TFor:
			// nested for
			nf, ni, err := parseFor(tokens, i)
			if err != nil {
				return nil, 0, err
			}
			node.Body = append(node.Body, nf)
			i = ni
			continue
		case TEndFor:
			if depth == 0 {
				return node, i + 1, nil
			}
			depth--
			node.Body = append(node.Body, &TextNode{Text: t.Value})
		case TIf:
			ifn, ni, err := parseIf(tokens, i)
			if err != nil {
				return nil, 0, err
			}
			node.Body = append(node.Body, ifn)
			i = ni
			continue
		case TSwitch:
			sn, ni, err := parseSwitch(tokens, i)
			if err != nil {
				return nil, 0, err
			}
			node.Body = append(node.Body, sn)
			i = ni
			continue
		default:
			switch t.Type {
			case TText:
				node.Body = append(node.Body, &TextNode{Text: t.Value})
			case TVar:
				node.Body = append(node.Body, &VarNode{Name: t.Value, Default: t.Default})
			default:
				return nil, 0, fmt.Errorf("unexpected token in for: %v", t.Type)
			}
			i++
		}
	}
	return nil, 0, fmt.Errorf("unclosed for starting at token %d", start)
}

func parseSwitch(tokens []*Token, start int) (*SwitchNode, int, error) {
	node := &SwitchNode{Expr: tokens[start].Value, Cases: []SwitchCase{}, Default: []Node{}}
	i := start + 1
	depth := 0
	currentCond := ""
	currentBody := []Node{}

	flushCase := func() {
		if currentCond != "" {
			node.Cases = append(node.Cases, SwitchCase{Cond: currentCond, Body: currentBody})
		} else if currentBody != nil && len(currentBody) > 0 {
			node.Default = currentBody
		}
		currentCond = ""
		currentBody = []Node{}
	}

	for i < len(tokens) {
		t := tokens[i]
		switch t.Type {
		case TSwitch:
			// nested
			nn, ni, err := parseSwitch(tokens, i)
			if err != nil {
				return nil, 0, err
			}
			currentBody = append(currentBody, nn)
			i = ni
			continue
		case TEndSwitch:
			if depth == 0 {
				flushCase()
				return node, i + 1, nil
			}
			depth--
			currentBody = append(currentBody, &TextNode{Text: t.Value})
		case TCase:
			if depth == 0 {
				// finish previous
				flushCase()
				currentCond = t.Value
				currentBody = []Node{}
				i++
				continue
			}
			currentBody = append(currentBody, &TextNode{Text: t.Value})
		case TDefault:
			if depth == 0 {
				flushCase()
				currentCond = ""
				currentBody = []Node{}
				i++
				continue
			}
			currentBody = append(currentBody, &TextNode{Text: t.Value})
		case TIf:
			in, ni, err := parseIf(tokens, i)
			if err != nil {
				return nil, 0, err
			}
			currentBody = append(currentBody, in)
			i = ni
			continue
		case TFor:
			fn, ni, err := parseFor(tokens, i)
			if err != nil {
				return nil, 0, err
			}
			currentBody = append(currentBody, fn)
			i = ni
			continue
		default:
			switch t.Type {
			case TText:
				currentBody = append(currentBody, &TextNode{Text: t.Value})
			case TVar:
				currentBody = append(currentBody, &VarNode{Name: t.Value, Default: t.Default})
			default:
				return nil, 0, fmt.Errorf("unexpected token in switch: %v", t.Type)
			}
			i++
		}
	}
	return nil, 0, fmt.Errorf("unclosed switch starting at token %d", start)
}

func evalNodes(nodes []Node, data map[string]interface{}) string {
	out := &strings.Builder{}
	for _, n := range nodes {
		out.WriteString(n.Eval(data))
	}
	return out.String()
}

// -------------------- Helpers / utilities --------------------

// lookup: dot notation support for map/struct
func lookup(data map[string]interface{}, path string) (interface{}, bool) {
	// if path is literal string "..." or number or boolean, don't treat as lookup
	p := strings.TrimSpace(path)
	if p == "" {
		return nil, false
	}
	// quoted string?
	if (strings.HasPrefix(p, "\"") && strings.HasSuffix(p, "\"")) || (strings.HasPrefix(p, "'") && strings.HasSuffix(p, "'")) {
		unq, err := strconv.Unquote(p)
		if err == nil {
			return unq, true
		}
	}
	// numeric literal?
	if i, err := strconv.Atoi(p); err == nil {
		return i, true
	}
	if f, err := strconv.ParseFloat(p, 64); err == nil {
		return f, true
	}
	if p == "true" {
		return true, true
	}
	if p == "false" {
		return false, true
	}

	var cur interface{} = data
	parts := strings.Split(p, ".")
	for _, seg := range parts {
		switch node := cur.(type) {
		case map[string]interface{}:
			v, ok := node[seg]
			if !ok {
				return nil, false
			}
			cur = v
		default:
			rv := reflect.ValueOf(cur)
			switch rv.Kind() {
			case reflect.Map:
				if rv.Type().Key().Kind() == reflect.String {
					mv := rv.MapIndex(reflect.ValueOf(seg))
					if !mv.IsValid() {
						return nil, false
					}
					cur = mv.Interface()
				} else {
					return nil, false
				}
			case reflect.Struct:
				f := rv.FieldByName(seg)
				if f.IsValid() {
					cur = f.Interface()
				} else {
					// try method? (not implemented)
					return nil, false
				}
			default:
				return nil, false
			}
		}
	}
	return cur, true
}

func lookupVal(data map[string]interface{}, path string) interface{} {
	v, _ := lookup(data, path)
	return v
}

func shallowCopyMap(m map[string]interface{}) map[string]interface{} {
	n := make(map[string]interface{}, len(m)+4)
	for k, v := range m {
		n[k] = v
	}
	return n
}

// -------------------- Filters --------------------

func applyFilter(name string, input string) string {
	switch name {
	case "upper":
		return strings.ToUpper(input)
	case "lower":
		return strings.ToLower(input)
	case "escape":
		return html.EscapeString(input)
	default:
		// unknown filter: passthrough
		return input
	}
}

// -------------------- Expression Evaluator (basit) --------------------
//
// Supports:
// - Comparisons: ==, !=, >, <, >=, <=
// - Logical: and, or (left-to-right, no operator precedence beyond that)
// - Parentheses not supported in this simple evaluator (could be added)
// - Left and right operands can be identifiers (dot notation), quoted strings, numbers, booleans.

var compOpRe = regexp.MustCompile(`\s*(==|!=|>=|<=|>|<)\s*`)

func evalCondition(expr string, data map[string]interface{}) (bool, error) {
	// split by " and " / " or " preserving order
	// implement left-to-right evaluation
	tokens := splitLogical(expr)
	if len(tokens) == 0 {
		// treat empty as false
		return false, nil
	}
	// tokens like: [cond, op, cond, op, cond...], where op is "and"/"or"
	// evaluate first cond
	res, err := evalSimpleCond(strings.TrimSpace(tokens[0]), data)
	if err != nil {
		return false, err
	}
	i := 1
	for i < len(tokens)-0 {
		op := strings.TrimSpace(tokens[i])
		nextExpr := strings.TrimSpace(tokens[i+1])
		nextRes, err := evalSimpleCond(nextExpr, data)
		if err != nil {
			return false, err
		}
		if op == "and" {
			res = res && nextRes
		} else if op == "or" {
			res = res || nextRes
		} else {
			return false, fmt.Errorf("unknown logical operator %s", op)
		}
		i += 2
		if i >= len(tokens) {
			break
		}
	}
	return res, nil
}

func splitLogical(expr string) []string {
	// naive split: find " and " and " or " tokens
	parts := []string{}
	cur := ""
	low := strings.TrimSpace(expr)
	words := strings.Fields(low)
	// rebuild by scanning tokens
	i := 0
	for i < len(words) {
		w := words[i]
		if w == "and" || w == "or" {
			parts = append(parts, strings.TrimSpace(cur))
			parts = append(parts, w)
			cur = ""
		} else {
			if cur == "" {
				cur = w
			} else {
				cur += " " + w
			}
		}
		i++
	}
	if cur != "" {
		parts = append(parts, strings.TrimSpace(cur))
	}
	return parts
}

func evalSimpleCond(cond string, data map[string]interface{}) (bool, error) {
	// If condition contains comparison operator -> split
	if compOpRe.MatchString(cond) {
		// loc := compOpRe.FindStringIndex(cond)
		op := compOpRe.FindStringSubmatch(cond)[1]
		parts := compOpRe.Split(cond, 2)
		if len(parts) != 2 {
			return false, fmt.Errorf("invalid comparison in '%s'", cond)
		}
		left := strings.TrimSpace(parts[0])
		right := strings.TrimSpace(parts[1])
		lv, lok := lookup(data, left)
		if !lok {
			// try literal
			lv = literalFromString(left)
		}
		rv, rok := lookup(data, right)
		if !rok {
			rv = literalFromString(right)
		}
		return compareValues(lv, rv, op)
	}
	// no operator => truthy check of the expression (variable or literal)
	v, ok := lookup(data, cond)
	if ok {
		return condTruthy(v), nil
	}
	// maybe it's literal
	v2 := literalFromString(cond)
	return condTruthy(v2), nil
}

func evalConditionWithValue(condExpr string, value interface{}, data map[string]interface{}) (bool, error) {
	// For switch-case convenience: if condExpr is a literal or simple comparison referencing 'value' or '.' shorthand
	// We'll replace occurrences of "value" or "." with actual value by injecting into data map as special var "__switch__"
	tmp := shallowCopyMap(data)
	tmp["__switch__"] = value
	// allow shorthand: if condExpr equals plain string/number, compare with value
	// But to reuse evalSimpleCond, we accept expressions like "__switch__ == 5" or simply "5" (then compare)
	// If condExpr has no operator, treat as equality to value.
	if compOpRe.MatchString(condExpr) {
		// eval normally but with lookup resolving identifiers possibly
		return evalCondition(condExpr, tmp)
	}
	// no operator: compare value stringified to condExpr literal or to evaluated lookup
	// try literal
	lit := literalFromString(strings.TrimSpace(condExpr))
	// compare value vs lit
	ok, err := compareValues(value, lit, "==")
	if err == nil && ok {
		return true, nil
	}
	// try comparing string form
	if fmt.Sprintf("%v", value) == fmt.Sprintf("%v", lit) {
		return true, nil
	}
	// else try evaluating cond as expression with __switch__ variable
	res, err := evalCondition(condExpr, tmp)
	if err == nil {
		return res, nil
	}
	return false, nil
}

func literalFromString(s string) interface{} {
	s = strings.TrimSpace(s)
	// quoted string
	if (strings.HasPrefix(s, "\"") && strings.HasSuffix(s, "\"")) || (strings.HasPrefix(s, "'") && strings.HasSuffix(s, "'")) {
		unq, err := strconv.Unquote(s)
		if err == nil {
			return unq
		}
		return s[1 : len(s)-1]
	}
	// bool
	if s == "true" {
		return true
	}
	if s == "false" {
		return false
	}
	// int
	if i, err := strconv.Atoi(s); err == nil {
		return i
	}
	// float
	if f, err := strconv.ParseFloat(s, 64); err == nil {
		return f
	}
	// fallback string
	return s
}

func compareValues(a interface{}, b interface{}, op string) (bool, error) {
	// first try numeric comparison
	af, aIsNum := toFloat(a)
	bf, bIsNum := toFloat(b)
	if aIsNum && bIsNum {
		switch op {
		case "==":
			return af == bf, nil
		case "!=":
			return af != bf, nil
		case ">":
			return af > bf, nil
		case "<":
			return af < bf, nil
		case ">=":
			return af >= bf, nil
		case "<=":
			return af <= bf, nil
		}
	}
	// boolean
	if ab, ok := a.(bool); ok {
		if bb, ok2 := b.(bool); ok2 {
			switch op {
			case "==":
				return ab == bb, nil
			case "!=":
				return ab != bb, nil
			}
		}
	}
	// string compare
	as := fmt.Sprintf("%v", a)
	bs := fmt.Sprintf("%v", b)
	switch op {
	case "==":
		return as == bs, nil
	case "!=":
		return as != bs, nil
	case ">":
		return as > bs, nil
	case "<":
		return as < bs, nil
	case ">=":
		return as >= bs, nil
	case "<=":
		return as <= bs, nil
	}
	return false, fmt.Errorf("unsupported comparison between %T and %T", a, b)
}

func toFloat(v interface{}) (float64, bool) {
	switch t := v.(type) {
	case int:
		return float64(t), true
	case int8:
		return float64(t), true
	case int16:
		return float64(t), true
	case int32:
		return float64(t), true
	case int64:
		return float64(t), true
	case uint:
		return float64(t), true
	case uint8:
		return float64(t), true
	case uint16:
		return float64(t), true
	case uint32:
		return float64(t), true
	case uint64:
		return float64(t), true
	case float32:
		return float64(t), true
	case float64:
		return t, true
	default:
		// try parse from string
		if s := fmt.Sprintf("%v", v); s != "" {
			if f, err := strconv.ParseFloat(s, 64); err == nil {
				return f, true
			}
		}
	}
	return 0, false
}

// -------------------- Truthy --------------------

func condTruthy(v interface{}) bool {
	if v == nil {
		return false
	}
	switch t := v.(type) {
	case bool:
		return t
	case string:
		return t != ""
	case int, int8, int16, int32, int64:
		return reflect.ValueOf(v).Int() != 0
	case uint, uint8, uint16, uint32, uint64:
		return reflect.ValueOf(v).Uint() != 0
	case float32, float64:
		return reflect.ValueOf(v).Float() != 0
	default:
		// slices/maps: non-empty => true
		rv := reflect.ValueOf(v)
		switch rv.Kind() {
		case reflect.Slice, reflect.Array, reflect.Map:
			return rv.Len() > 0
		default:
			return true
		}
	}
}
